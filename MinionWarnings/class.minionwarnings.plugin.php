<?php

/**
 * @copyright 2003 Vanilla Forums, Inc
 * @license Proprietary
 */

$PluginInfo['MinionWarnings'] = array(
    'Name' => 'Minion: Warnings',
    'Description' => "Allow Minion to issue warnings with Warnings2",
    'Version' => '1.0',
    'RequiredApplications' => array(
        'Vanilla' => '2.2'
    ),
    'RequiredPlugins' => array(
        'Warnings2' => '2.1b'
    ),
    'MobileFriendly' => true,
    'Author' => "Tim Gunter",
    'AuthorEmail' => 'tim@vanillaforums.com',
    'AuthorUrl' => 'http://vanillaforums.com'
);

/**
 * Minion Warnings Plugin
 *
 * This plugin acts as a provider to allow minion's punishment event to be handled by the Warnings system.
 *
 * Changes:
 *  1.0     Release
 *
 * @author Tim Gunter <tim@vanillaforums.com>
 * @package minion
 */
class MinionWarningsPlugin extends Gdn_Plugin {

    /**
     * Hook for E:Token from MinionPlugin
     *
     * Parse a token from the current state while running checkCommands. This method allows us to intercept
     * and support manual infractions.
     *
     * @param MinionPlugin $sender
     */
    public function minionPlugin_token_handler($sender) {
        $state = &$sender->EventArguments['State'];

        // Warnings
        if (!$state['Method'] && in_array($state['CompareToken'], array('warn', 'warning', 'infract', 'infraction'))) {
            $sender->consume($state, 'Method', 'warn');
        }

        // Bans
        if (!$state['Method'] && in_array($state['CompareToken'], array('ban'))) {
            $sender->consume($state, 'Method', 'ban');
        }
    }

    /**
     * Hook for E:Command from MinionPlugin
     *
     * Parse custom minion commands. This method adds action handling for the commands matched during token parsing and
     * queueing associates command execution.
     *
     * @param MinionPlugin $sender
     */
    public function minionPlugin_command_handler($sender) {
        $actions = &$sender->EventArguments['Actions'];
        $state = &$sender->EventArguments['State'];

        // If we don't know the targetted user, try to detect by a quote
        if (!array_key_exists('User', $state['Targets'])) {
            $sender->matchQuoted($state);
        }

        switch ($state['Method']) {
            case 'warn':
                $actions[] = array('warn', C('Minion.Access.Warn', 'Garden.Moderation.Manage'), $state);
                break;

            case 'ban':
                $actions[] = array('ban', C('Minion.Access.Ban', 'Garden.Moderation.Manage'), $state);
                break;
        }
    }

    /**
     * Hook for E:Action from MinionPlugin
     *
     * Perform custom minion actions. This method handles the queued actions generated by matching commands from user
     * input.
     *
     * @param MinionPlugin $sender
     */
    public function minionPlugin_action_handler($sender) {
        $action = $sender->EventArguments['Action'];
        $state = $sender->EventArguments['State'];

        switch ($action) {

            case 'warn':
            case 'ban':

                if (!array_key_exists('User', $state['Targets'])) {
                    $sender->acknowledge(null, T('You must supply a valid target user.'), 'custom', $state['Sources']['User'], array(
                        'Comment' => false
                    ));
                    break;
                }

                $discussion = $state['Targets']['Discussion'];
                $targetUser = $state['Targets']['User'];

                $warnings = [];

                if ($targetUser === "thread") {
                    $commentModel = new CommentModel();
                    $comments = $commentModel->getWhere([
                        'DiscussionID' => $discussion['DiscussionID']
                    ]);

                    foreach ($comments as $comment) {
                        $user = Gdn::userModel()->getID($comment['InsertUserID']);
                        if (Gdn::userModel()->checkPermission($user, ['Garden.Settings.Manage','Garden.Moderation.Manage'])) {
                            continue;
                        }
                        $warnings[] = [
                            'user' => $user,
                            'comment' => $comment
                        ];
                    }
                } else {
                    $recordComment = val('Comment', $state['Targets'], null);
                    $warnings[] = [
                        'user' => $targetUser,
                        'comment' => $recordComment
                    ];
                }

                if (!count($warnings)) {
                    $sender->acknowledge(null, T('You must supply a valid target user.'), 'custom', $state['Sources']['User'], array(
                        'Comment' => false
                    ));
                    break;
                }

                $force = val('Force', $state, MinionPlugin::FORCE_MEDIUM);

                $options = array(
                    'Automated' => false,
                    'Cause' => 'manually invoked by ' . userAnchor($state['Sources']['User']) . '.'
                );

                // Try to deduce a reason
                $reason = val('Reason', $state, null);
                if (empty($reason)) {
                    $reason = val('Gravy', $state, null);
                }

                if (!empty($reason)) {
                    $options['Reason'] = $reason;
                }

                // Try to deduce expiry
                $expiry = val('Time', $state, null);
                if (!empty($expiry)) {
                    $options['Expires'] = $expiry;
                }

                $options['Invoker'] = $state['Sources']['User'];

                $gloat = count($warnings) > 1 ? false : true;
                foreach ($warnings as $warning) {
                    $punished = $sender->punish(
                        $warning['user'],
                        $discussion,
                        $warning['comment'],
                        $force,
                        $options
                    );

                    if ($gloat) {
                        $gloatReason = val('GloatReason', $sender->EventArguments);
                        if ($punished && $gloatReason) {
                            $sender->gloat($state['Targets']['User'], $state['Sources']['Discussion'], $gloatReason);
                        }
                    }
                }

                break;
        }
    }

    /**
     * Hook for E:Punish from MinionPlugin
     *
     * Perform punish actions using Infractions calls.
     *
     * @param MinionPlugin $sender
     */
    public function minionPlugin_punish_handler($sender) {
        $punished = &$sender->EventArguments['Punished'];
        $user = &$sender->EventArguments['User'];
        $discussion = &$sender->EventArguments['Discussion'];
        $comment = &$sender->EventArguments['Comment'];
        $force = &$sender->EventArguments['Force'];
        $options = &$sender->EventArguments['Options'];

        $userID = val('UserID', $user);
        $discussionID = val('DiscussionID', $discussion, 0);
        $commentID = val('CommentID', $comment, 0);

        $reason = val('Reason', $options, '');
        $automated = val('Automated', $options, true);

        switch ($force) {

            case MinionPlugin::FORCE_LETHAL:
                $type = 'banned';
                $points = val('Points', $options, 8);
                $class = 'ban';
                $warning = val('Points', $options, 0);
                $expires = val('Expires', $options, "4 weeks");
                break;

            case MinionPlugin::FORCE_HIGH:
                $type = 'warned';
                $points = val('Points', $options, 3);
                $class = 'major';
                $warning = val('Points', $options, 0);
                $expires = val('Expires', $options, "2 weeks");
                break;

            case MinionPlugin::FORCE_MEDIUM:
                $type = 'warned';
                $points = val('Points', $options, 2);
                $class = 'minor';
                $warning = val('Points', $options, 0);
                $expires = val('Expires', $options, "1 week");
                break;

            case MinionPlugin::FORCE_LOW:
                $type = 'warned';
                $points = val('Points', $options, 0);
                $class = 'warning';
                $warning = val('Warning', $options, 1);
                $expires = val('Expires', $options, "1 week");
                break;

            default:
                return;
        }

        $mod = array();

        $note = $automated ? formatString(T('Automated warning assigned by {Minion.Name}. '), array(
            'Minion' => $sender->minion()
        )) : '';
        if (array_key_exists('Invoker', $options)) {
            $note .= sprintf(T('Invoked by %s. '), valr('Invoker.Name', $options));
            $mod['InsertUserID'] = $sender->getMinionUserID();
        }

        // Don't let non-mods issue warnings
        if (!Gdn::session()->checkPermission('Garden.Moderation.Manage')) {
            $mod['InsertUserID'] = $sender->getMinionUserID();
        }

        if ($expires) {
            $note .= $expires;
        }

        // Send 'Expires' back
        $options['Expires'] = $expires;

        $message = "{$reason}\n\n{$note}";

        $warnings = new WarningModel();
        $warning = array(
            'UserID' => $userID,
            'Body' => $message,
            'Format' => 'TextEx',
            'Points' => $points,
            'ExpiresString' => $expires == null ? null : "+ {$expires}"
        );

        // Locally modify before saving
        $warning = array_merge($warning, $mod);

        if ($commentID) {
            $warning = array_merge($warning, array(
                'RecordType' => 'comment',
                'RecordID' => $commentID
            ));
        } else if ($discussionID) {
            $warning = array_merge($warning, array(
                'RecordType' => 'discussion',
                'RecordID' => $discussionID
            ));
        }

        // Create warning
        $warning = $warnings->save($warning);

        // Generate a gloat reason
        $gloatReason = ucfirst($type) . " @\"{User.Name}\" ({$points} " . plural($points, 'point', 'points') . " for {$expires})";
        if (!empty($reason)) {
            $gloatReason .= " for \"{$reason}\"";
        }

        $sender->EventArguments['Infraction'] = $warning;
        $sender->EventArguments['GloatReason'] = $gloatReason;
        $punished = true;
    }

    /**
     * Infract users for 3 points if they are caught
     *
     * @param HunterPlugin $sender
     */
    public function hunterPlugin_fugitiveCatch_handler($sender) {
        $user = $sender->EventArguments['User'];

        $points = $this->JailThreshold;
        $warning = 0;
        $expires = '1 day';

        $reason = $sender->EventArguments['Message'];
        $reason .= "\nYou have been weighed, you have been measured, and you have been found wanting. In what world could you possibly beat me?";

        $note = "Played 'Hunter' and was caught. Jailed for 1 day.";

        $warnings = new WarningModel();
        $warning = $warnings->save(array(
            'UserID' => $user['UserID'],
            'InsertUserID' => MinionPlugin::instance()->getMinionUserID()
        ), array(
            'Points' => $points,
            'Warning' => $warning,
            'Expires' => $expires == null ? null : Gdn_Format::toDateTime(strtotime('+ ' . $expires))
        ), array(
            'Reason' => $reason,
            'BanReason' => $reason,
            'Note' => $note,
            'Title' => $reason . ' -- ' . val('Name', $user),
            'Message' => $reason
        ));
    }

}