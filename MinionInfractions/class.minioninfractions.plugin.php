<?php

/**
 * @copyright 2003 Vanilla Forums, Inc
 * @license Proprietary
 */

$PluginInfo['MinionInfractions'] = array(
    'Name' => 'Minion: Infractions',
    'Description' => "Allow Minion to issue infractions with Infractions",
    'Version' => '1.0',
    'RequiredApplications' => array(
        'Vanilla' => '2.2'
    ),
    'RequiredPlugins' => array(
        'Infractions' => '1.4.1'
    ),
    'MobileFriendly' => true,
    'Author' => "Tim Gunter",
    'AuthorEmail' => 'tim@vanillaforums.com',
    'AuthorUrl' => 'http://vanillaforums.com'
);

/**
 * Minion Infractions Plugin
 *
 * This plugin acts as a provider to allow minion's punishment event to be handled by the Infractions system.
 *
 * Changes:
 *  1.0     Release
 *
 * @author Tim Gunter <tim@vanillaforums.com>
 * @package minion
 */
class MinionInfractionsPlugin extends Gdn_Plugin {

    /**
     * Hook for E:Token from MinionPlugin
     *
     * Parse a token from the current state while running checkCommands. This method allows us to intercept
     * and support manual infractions.
     *
     * @param MinionPlugin $sender
     */
    public function MinionPlugin_Token_Handler($sender) {
        $state = &$sender->EventArguments['State'];

        // Warnings
        if (!$state['Method'] && in_array($state['CompareToken'], array('warn', 'warning'))) {
            $sender->consume($state, 'Method', 'warn');
        }

        // Infractions
        if (!$state['Method'] && in_array($state['CompareToken'], array('encourage', 'infract', 'infraction'))) {
            $sender->consume($state, 'Method', 'infract');
        }

        // Bans
        if (!$state['Method'] && in_array($state['CompareToken'], array('ban'))) {
            $sender->consume($state, 'Method', 'ban');
        }
    }

    /**
     * Hook for E:Command from MinionPlugin
     *
     * Parse custom minion commands. This method adds action handling for the commands matched during token parsing and
     * queueing associates command execution.
     *
     * @param MinionPlugin $sender
     */
    public function MinionPlugin_Command_Handler($sender) {
        $actions = &$sender->EventArguments['Actions'];
        $state = &$sender->EventArguments['State'];

        switch ($state['Method']) {
            case 'infract':
            case 'warn':
            case 'ban':

                // If we don't know the originating user, try to detect by a quote
                if (!array_key_exists('User', $state['Targets'])) {
                    $sender->matchQuoted($state);
                }

                if (array_key_exists('User', $state['Targets'])) {
                    $actions[] = array('infract', C('Minion.Access.Warn', 'Garden.Moderation.Manage'), $state);
                }

                break;
        }
    }

    /**
     * Hook for E:Action from MinionPlugin
     *
     * Perform custom minion actions. This method handles the queued actions generated by matching commands from user
     * input.
     *
     * @param MinionPlugin $sender
     */
    public function MinionPlugin_Action_Handler($sender) {
        $action = $sender->EventArguments['Action'];
        $state = $sender->EventArguments['State'];

        switch ($action) {

            case 'infract':
            case 'warn':
            case 'ban':

                if (!array_key_exists('User', $state['Targets'])) {
                    return;
                }

                $force = val('Force', $state, MinionPlugin::FORCE_MEDIUM);

                if ($state['Method'] == 'ban') {
                    $force = MinionPlugin::FORCE_LETHAL;
                }

                if ($state['Method'] == 'warn') {
                    $force = MinionPlugin::FORCE_LOW;
                }

                $options = array(
                    'Automated' => false,
                    'Cause' => 'manually invoked by ' . userAnchor($state['Sources']['User']) . '.'
                );

                // Try to deduce a reason
                $reason = val('Reason', $state, null);
                if (empty($reason)) {
                    $reason = val('Gravy', $state, null);
                }

                if (!empty($reason)) {
                    $options['Reason'] = $reason;
                }

                // Try to deduce expiry
                $expiry = val('Time', $state, null);
                if (!empty($expiry)) {
                    $options['Expires'] = $expiry;
                }

                $options['Invoker'] = $state['Sources']['User'];

                $recordComment = val('Comment', $state['Targets'], null);
                $punished = $sender->punish(
                    $state['Targets']['User'], $state['Targets']['Discussion'], $recordComment, $force, $options
                );

                $gloatReason = val('GloatReason', MinionPlugin::instance()->EventArguments);
                if ($punished && $gloatReason) {
                    $sender->gloat($state['Targets']['User'], $state['Sources']['Discussion'], $gloatReason);
                }

                break;
        }
    }

    /**
     * Hook for E:Punish from MinionPlugin
     *
     * Perform punish actions using Infractions calls.
     *
     * @param MinionPlugin $sender
     */
    public function MinionPlugin_Punish_Handler($sender) {
        $punished = &$sender->EventArguments['Punished'];
        $user = &$sender->EventArguments['User'];
        $discussion = &$sender->EventArguments['Discussion'];
        $comment = &$sender->EventArguments['Comment'];
        $force = &$sender->EventArguments['Force'];
        $options = &$sender->EventArguments['Options'];

        $userID = val('UserID', $user);
        $discussionID = val('DiscussionID', $discussion, 0);
        $commentID = val('CommentID', $comment, 0);

        $reason = val('Reason', $options, '');
        $automated = val('Automated', $options, true);

        switch ($force) {

            case MinionPlugin::FORCE_LETHAL:
                $type = 'banned';
                $points = 8;
                $warning = 0;
                $expires = val('Expires', $options, "30 days");
                break;

            case MinionPlugin::FORCE_HIGH:
                $type = 'infracted';
                $points = 3;
                $warning = 0;
                $expires = val('Expires', $options, "60 days");
                break;

            case MinionPlugin::FORCE_MEDIUM:
                $type = 'infracted';
                $points = 2;
                $warning = 0;
                $expires = val('Expires', $options, "30 days");
                break;

            case MinionPlugin::FORCE_LOW:
            default:
                $type = 'warned';
                $points = 0;
                $warning = 1;
                $expires = val('Expires', $options, "30 days");
                break;
        }

        $note = $automated ? formatString(T('Automated infraction assigned by {Minion.Name}. '), array(
            'Minion' => $sender->minion()
        )) : '';
        if (array_key_exists('Invoker', $options)) {
            $note .= sprintf(T('Invoked by %s. '), valr('Invoker.Name', $options));
        }

        if ($expires) {
            $note .= $expires;
        }

        // Send 'Expires' back
        $options['Expires'] = $expires;

        $infraction = InfractionsPlugin::instance()->infract(array(
            'UserID' => $userID,
            'DiscussionID' => $discussionID,
            'CommentID' => $commentID,
            'InsertUserID' => $sender->getMinionUserID()
        ), array(
            'Points' => $points,
            'Warning' => $warning,
            'Expires' => $expires == null ? null : Gdn_Format::toDateTime(strtotime('+ ' . $expires))
        ), array(
            'Reason' => $reason,
            'BanReason' => $reason,
            'Note' => $note,
            'Title' => $reason . ' -- ' . val('Name', $user),
            'Message' => $reason
        ));

        // Generate a gloat reason
        $gloatReason = ucfirst($type) . " @\"{User.Name}\" ({$points} " . plural($points, 'point', 'points') . " for {$expires}) for \"{$reason}\"";

        $sender->EventArguments['Infraction'] = $infraction;
        $sender->EventArguments['GloatReason'] = $gloatReason;
        $punished = true;
    }

    /**
     * Infract users for 3 points if they are caught
     *
     * @param HunterPlugin $sender
     */
    public function HunterPlugin_FugitiveCatch_Handler($sender) {
        $user = $sender->EventArguments['User'];

        $points = $this->JailThreshold;
        $warning = 0;
        $expires = '1 day';

        $reason = $sender->EventArguments['Message'];
        $reason .= "\nYou have been weighed, you have been measured, and you have been found wanting. In what world could you possibly beat me?";

        $note = "Played 'Hunter' and was caught. Jailed for 1 day.";

        $infraction = InfractionsPlugin::instance()->infract(array(
            'UserID' => $user['UserID'],
            'InsertUserID' => MinionPlugin::instance()->getMinionUserID()
        ), array(
            'Points' => $points,
            'Warning' => $warning,
            'Expires' => $expires == null ? null : Gdn_Format::toDateTime(strtotime('+ ' . $expires))
        ), array(
            'Reason' => $reason,
            'BanReason' => $reason,
            'Note' => $note,
            'Title' => $reason . ' -- ' . val('Name', $user),
            'Message' => $reason
        ));
    }

}